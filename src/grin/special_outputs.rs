use crate::{KeyPair, PublicKey};

/// Special outputs allow the signing phase to occur without knowledge of the
/// actual wallet outputs of either party. They can be generated locally and
/// will be erased via cut-through even before a transaction involving them is
/// published to the blockchain.

#[derive(Clone)]
pub struct SpecialOutputs {
    pub fund_input_key: PublicKey,
    pub redeem_output_key: PublicKey,
    pub refund_output_key: PublicKey,
}

/// Special output keypairs owned by the funder.
///
/// The fund transaction generated by the protocol will spend from the output
/// corresponding to the `fund_input_key`. Another transaction paying to the
/// `fund_input_key` from the funder's wallet will need to be aggregated in
/// order to produce a valid transaction.
///
/// Similarly, the refund transaction generated by the protocol will pay to the
/// output corresponding to the `refund_output_key`. Another transaction
/// spending from the `refund_output_key` to the funder's wallet will need to be
/// aggregated in order to produce a valid refund transaction.
#[derive(Debug, Clone)]
pub struct SpecialOutputKeyPairsFunder {
    pub fund_input_key: KeyPair,
    pub refund_output_key: KeyPair,
}

impl SpecialOutputKeyPairsFunder {
    pub fn new_random() -> Self {
        Self {
            fund_input_key: KeyPair::new_random(),
            refund_output_key: KeyPair::new_random(),
        }
    }
}

/// Special output keypairs owned by the redeemer.
///
/// The redeem transaction generated by the protocol will pay to the output
/// corresponding to the `redeem_output_key`. Another transaction spending from
/// the `redeem_output_key` to the redeemer's wallet will need to be aggregated
/// in order to produce a valid redeem transaction.
#[derive(Debug, Clone)]
pub struct SpecialOutputKeyPairsRedeemer {
    pub redeem_output_key: KeyPair,
}

impl SpecialOutputKeyPairsRedeemer {
    pub fn new_random() -> Self {
        Self {
            redeem_output_key: KeyPair::new_random(),
        }
    }
}
