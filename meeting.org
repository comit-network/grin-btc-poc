* From spec to implementation
** What has changed
*** No need to provide any Grin wallet keys (or fees)
As documented in one of the original drafts of the protocol specification, we attempted to avoid the need to provide Grin wallet keys for signing purposes, inspired by [[https://eprint.iacr.org/2018/1039.pdf][this paper]].

We succeeded in doing so by constructing all the transactions using "proxy" outputs (in the code they're called special outputs to reference the name used in the paper).

To outline the way this works we can use the fund transaction as an example:

1. Prior to the key generation phase, the funder generates a keypair a proxy fund input locally and shares its public key with the redeemer.
2. During the signing phase, the proxy fund input keys are treated as if the proxy fund input was the actual wallet input of the funder.

   This is how the resulting fund transaction looks like:

   | Inputs           | Outputs     | Kernels                |
   |------------------+-------------+------------------------|
   | proxy fund input | fund output | excess, signature, fee |

3. During the execution phase, we create a Grin invoice slate with the proxy fund input as an /output/ and pass it on to the funder's wallet, which will fill in the input(s) and change output(s) accordingly:

   | Inputs               | Outputs                            | Kernels                |
   |----------------------+------------------------------------+------------------------|
   | wallet fund input(s) | proxy fund input, change output(s) | excess, signature, fee |

4. Using another Grin wallet API, we can aggregate these transactions, eliminating the proxy fund input via cut-through (since it appears both as an input and as an output) and producing a transaction with two kernels (hence the often used name "double kernel trick"):

   | Inputs               | Outputs                              | Kernels                |
   |----------------------+--------------------------------------+------------------------|
   | wallet fund input(s) | +proxy fund input+, change output(s) | excess, signature, fee |
   | +proxy fund input+   | fund output                          | excess, signature, fee |

   This transaction is then broadcast to the Grin network.

   N.B. Despite showing two transaction fees in the aggregate transaction, the transaction fees don't have to be higher. It is perfectly acceptable to set one of the fees to 0 (as we do in the implementation). A nice side effect of this is that *Grin transaction fees do not need to be exchanged or negotiated*, since all the transactions generated by the protocol (before wallets are involved) can have a 0 fee.
*** Multi-party bulletproof generation
Every Grin output needs to include a bulletproof (a specific type of rangeproof) in order to certify that said output is not negative, without revealing its actual value. It is trivial for one party to generate the bulletproof for an output solely owned by them. For outputs "owned" by multiple parties (composed of several private keys or blinding factors), these parties need to engage in a protocol to jointly generate its bulletproof. This is the case of the fund output in our protocol.

The original specification did not properly describe how this would be done, so it was left to the implementers to decide how to tackle this. Grin already provides a way to do this, but the API is objectively terrible and the implementation does not inspire confidence. We made some efforts to use better libraries, but converting between different representations proved to be very challenging and time-consuming. With this in mind we decided to roll with [[file:src/grin/bulletproof.rs::pub struct Round1 {][Grin's multi-party bulletproof API for the PoC]]. It is used almost exactly [[https://i.imgur.com/s7exNSf.png][like the main developer behind it envisioned]], with slight tweaks suggested by Lloyd.

Lloyd is adamant that we should not use this in production. My *non-expert* opinion is that yes, the API and implementation seems very bad, but it's what Grin provides. We could contribute back to them (assuming they would welcome changes), but I'm not sure that improving their libraries needs to be part of adding this protocol to cnd.
*** Generated Grin redeem nonces (and y) may need to be negated
This is due to a very specific Grin quirk, which only accepts signatures generated with a nonce whose y-coordinate is a quadratic residue. In our case the nonce for the redeem transaction signature is a combination of R_redeem^funder, R_redeem^redeemer and Y. During key generation we need to verify whether these combine to satisfy the condition, and if not we negate them all.

Since we decided to start the signing phase before the key generation is fully complete in order to reduce the number of messages, in the PoC there is [[file:src/alice.rs::// Building the opening must happen now, because some keys may change when][some coupling between the two phases]]. This could be easily avoided by completely separating both phases, increasing the number of messages. It also leads to code that is easier to reason about.
* Limitations
** Dependency on rust-bitcoin fork
** Use of purpose-built Bitcoin wallet
An extremely specific wallet was built to sign the Bitcoin fund input. We wanted to use [[https://github.com/rust-bitcoin/rust-wallet][rust-bitcoin's wallet]], but it depends on rust-bitcoin, which in turn depends on secp256k1, which clashes with secp256k1-zkp.

We think that for a proof of concept this is okay, but I believe we need to verify that there are Bitcoin wallets out there that allow you to sign particular inputs of a transaction, so that we can use it in cnd's e2e test suite and provide it on the SDK.
** Need to provide Bitcoin wallet output
The funder of Bitcoin needs to ask their wallet for an output with which to fund, long *before* funding takes place. This is so that valid signatures can be produced during the signing phase.

This was documented when we first wrote the specification, but it results in an unergonomic API, which differs from the other COMIT protocols.
** Use of simulated Grin node
Instead of running a Grin node in local development mode like we do for Bitcoin, Grin offers a way to spawn a test Grin node from within Rust. This is how Grin does some of their e2e testing. It could also be seen as a feature, since this allowed us to more easily stay in Rust, one of the objectives of the implementation.

In any case, in order to conform to our TypeScript e2e test suite we will need to figure out how to properly configure a Grin node for local development. We tried and failed for a while before discovering the Rust way.
